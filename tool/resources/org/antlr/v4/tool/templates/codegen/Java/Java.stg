javaTypeInitMap ::= [
	"int":"0",
	"long":"0",
	"float":"0.0f",
	"double":"0.0",
	"boolean":"false",
	"byte":"0",
	"short":"0",
	"char":"0",
	default:"null" // anything other than an atomic type
]

// args must be <object-model-object>, <fields-resulting-in-STs>

ParserFile(file, parser, namedActions) ::= <<
// $ANTLR ANTLRVersion> <file.fileName> generatedTimestamp>
<namedActions.header>
import org.antlr.v4.runtime.NoViableAltException;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.EarlyExitException;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.FailedPredicateException;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.*;
import java.util.List;
import java.util.ArrayList;

<parser>
>>

Parser(parser, scopes, funcs, atn, actions, sempreds) ::= <<
public class <parser.name> extends Parser {
    public static final int
        <parser.tokens:{k | <k>=<parser.tokens.(k)>}; separator=", ", wrap, anchor>;
    public static final String[] tokenNames = {
        "\<INVALID>", "\<INVALID>", "\<INVALID>",
        <parser.tokenNames:{k | "<k>"}; separator=", ", wrap, anchor>
    };
    public static final String[] ruleNames = {
        "\<INVALID>",
        <parser.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor>
    };
    <scopes>
    <namedActions.members>
    <parser:ctor()>
    <funcs; separator="\n">

    @Override
    public String[] getTokenNames() { return tokenNames; }
    @Override
    public String[] getRuleNames() { return ruleNames; }
	@Override
	public ATN getATN() { return _ATN; }

    <dumpActions(actions,sempreds)>
    <atn>
}
>>

dumpActions(actions,sempreds) ::= <<
<if(sempreds)>
	public boolean sempred(int ruleIndex, int predIndex) {
		switch ( predIndex ) {
		    <sempreds:{index|
case <index> : return <sempreds.(index)>;}; separator="\n">
    	}
		return true;
	}
<endif>
<if(actions)>
	public void action(int ruleIndex, int actionIndex) {
		switch ( actionIndex ) {
		    <actions:{index|
case <index> : <actions.(index)> break;}; separator="\n">
    	}
	}
<endif>
>>

ctor(p) ::= <<
public <p.name>(TokenStream input) {
    super(input);
    _interp = new ParserInterpreter(this,_ATN);
}
>>

RuleFunction(currentRule,code,locals,ruleCtx,namedActions,finallyAction,postamble) ::= <<
<ruleCtx>
public QStack\<<currentRule.ctxType>\> <currentRule.name>_stk = new QStack\<<currentRule.ctxType>\>();

<if(currentRule.modifiers)><currentRule.modifiers:{f | <f> }><else>public final <endif><currentRule.ctxType> <currentRule.name>(<currentRule.args; separator=",">) throws RecognitionException {
    <currentRule.ctxType> _localctx = new <currentRule.ctxType>(_ctx, <currentRule.startState><currentRule.args:{a | , <a.name>}>);
    _ctx = _localctx;
    <currentRule.name>_stk.push(_localctx);
    _localctx.start = input.LT(1);
    //System.out.println("enter "+ruleNames[<currentRule.index>]);
    <namedActions.init>
    <locals; separator="\n">
	try {
	    <code>
        _localctx.stop = input.LT(-1);
	    <postamble; separator="\n">
        <namedActions.after>
	}
	catch (RecognitionException re) {
		reportError(re);
		recover();
	}
	finally {
        <currentRule.name>_stk.pop();
        _ctx = (ParserRuleContext)_ctx.parent;
        <finallyAction>
    	//System.out.println("exit "+ruleNames[<currentRule.index>]);
	}
    return _localctx;
}
>>

CodeBlock(c, ops) ::= <<
<ops; separator="\n">
>>

LL1AltBlock(choice, alts, error) ::= <<
switch ( input.LA(1) ) {
	<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
	default :
		<error>
}
>>

LL1OptionalBlock(choice, alts, error) ::= <<
switch ( input.LA(1) ) {
	<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
	default :
		<error>
}
>>

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
<preamble; separator="\n">
if ( <expr> ) {
    <alts; separator="\n">
}
<!else if ( !(<followExpr>) ) <error>!>
>>

LL1StarBlock(choice, alts, sync) ::= <<
<choice.loopLabel>:
while (true) {
	switch ( input.LA(1) ) {
		<choice.altLook,alts:{look,alt| <cases(look)>
	<alt>
		break;}; separator="\n">
		<cases(choice.exitLook)>
		    break <choice.loopLabel>;
	}
    //<sync>
}
>>

LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration, sync) ::= <<
<preamble; separator="\n">
while ( <loopExpr> ) {
    <alts; separator="\n">
    <iteration>
    //<sync>
}
>>

LL1PlusBlock(choice, alts, iteration, loopExpr, sync, error, iterationSync) ::= <<
//<sync>
do {
	switch ( input.LA(1) ) {
		<choice.altLook,alts:{look,alt| <cases(look)>
	<alt>
	break;}; separator="\n">
        default :
            <error>
	}
    <iteration>
    //<iterationSync>
} while ( <loopExpr> );
>>

LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration,
                      sync, iterationSync) ::=
<<
//<sync>
<preamble; separator="\n">
do {
    <alts; separator="\n">
    <iteration>
//    <iterationSync>
} while ( <loopExpr> );
>>

// LL(*) stuff

AltBlock(choice, alts, error) ::= <<
switch ( _interp.adaptivePredict(input,<choice.decision>,_ctx) ) {
	<alts:{alt |
case <i>:
	<alt>
	break;}; separator="\n">
	default :
		<error>
}
>>

OptionalBlock(choice, alts, error) ::= <<
switch ( _interp.adaptivePredict(input,<choice.decision>,_ctx) ) {
	<alts:{alt |
case <i>:
	<alt>
	break;}; separator="\n">
}
>>

StarBlock(choice, alts, sync) ::= <<
int _alt<choice.uniqueID> = _interp.adaptivePredict(input,<choice.decision>,_ctx);
while ( _alt<choice.uniqueID>!=<choice.exitAlt> ) {
	switch ( _alt<choice.uniqueID> ) {
		<alts:{alt|
case <i>:
	<alt>
	break;}; separator="\n">
	}
	_alt<choice.uniqueID> = _interp.adaptivePredict(input,<choice.decision>,_ctx);
}
>>

PlusBlock(choice, alts, error) ::= <<
int _alt<choice.uniqueID> = _interp.adaptivePredict(input,<choice.decision>,_ctx);
do {
	switch ( _alt<choice.uniqueID> ) {
		<alts:{alt|
case <i>:
	<alt>
	break;}; separator="\n">
	    default :
		    <error>
	}
	_alt<choice.uniqueID> = _interp.adaptivePredict(input,<choice.decision>,_ctx);
} while ( _alt<choice.uniqueID>!=<choice.exitAlt> );
>>

Sync(s) ::= "sync(<s.expecting.name>);"

ThrowNoViableAlt(t) ::= "throw new NoViableAltException(this,_ctx);"

TestSetInline(s) ::= <<
<s.ttypes:{ttype | <s.varName>==<ttype>}; separator=" || ">
>>

cases(ttypes) ::= <<
<ttypes:{t | case <t>:}; separator="\n">
>>

InvokeRule(r) ::= <<
_localctx.s = <r.stateNumber>;
<if(r.labels)><r.labels:{l | <labelref(l)> = }><endif><r.name>(<r.argExprs:{e| <e>}; separator=",">);
>>

MatchToken(m) ::= <<
_localctx.s = <m.stateNumber>;
<if(m.labels)><m.labels:{l | <labelref(l)> = }>(Token)<endif>match(<m.name>);
>>

// ACTION STUFF

Action(a, chunks) ::= "<chunks>"

ForcedAction(a, chunks) ::= "<chunks>"

SemPred(p, chunks) ::= <<
if (!(<chunks>)) throw new FailedPredicateException(this, input, "<currentRule.name>", ""<!"<chunks>"!>);
>>

ActionText(t) ::= "<t.text>"
ArgRef(a) ::= "_localctx.<a.name>"
RetValueRef(a) ::= "_localctx.<a.name>"
QRetValueRef(a) ::= "<a.dict>.<a.name>"
/** How to translate $tokenLabel */
TokenRef(t) ::= "<if(!t.isLocal)>_localctx.<endif><t.name>"
SetAttr(s,rhsChunks) ::= "_localctx.<s.name> = <rhsChunks>;"
LexerSetAttr(s,rhsChunks) ::= "<s.name> = <rhsChunks>;"
//SetQAttr(s,rhsChunks) ::= "<s.dict>.<s.name> = <rhsChunks>;"

TokenPropertyRef_text(t) ::= "(_localctx.<t.label>!=null?_localctx.<t.label>.getText():null)"
TokenPropertyRef_type(t) ::= "(_localctx.<t.label>!=null?_localctx.<t.label>.getType():0)"
TokenPropertyRef_line(t) ::= "(_localctx.<t.label>!=null?_localctx.<t.label>.getLine():0)"
TokenPropertyRef_pos(t) ::= "(_localctx.<t.label>!=null?_localctx.<t.label>.getCharPositionInLine():0)"
TokenPropertyRef_channel(t) ::= "(_localctx.<t.label>!=null?_localctx.<t.label>.getChannel():0)"
TokenPropertyRef_index(t) ::= "(_localctx.<t.label>!=null?_localctx.<t.label>.getTokenIndex():0)"
TokenPropertyRef_tree(t) ::= "_localctx.<t.label>_tree"
TokenPropertyRef_int(t) ::= "(_localctx.<t.label>!=null?Integer.valueOf(_localctx.<t.label>.getText()):0)"

RulePropertyRef_start(r) ::= "(_localctx.<r.label>!=null?((<file.TokenLabelType>)_localctx.<r.label>.start):null)"
RulePropertyRef_stop(r)  ::= "(_localctx.<r.label>!=null?((<file.TokenLabelType>)_localctx.<r.label>.stop):null)"
RulePropertyRef_tree(r)  ::= "(_localctx.<r.label>!=null?((<file.ASTLabelType>)_localctx.<r.label>.tree):null)"
RulePropertyRef_text(r)  ::= "(_localctx.<r.label>!=null?((TokenStream)input).toString(_localctx.<r.label>.start,_localctx.<r.label>.stop):null)"
RulePropertyRef_st(r)    ::= "(_localctx.<r.label>!=null?_localctx.<r.label>.st:null)"

DynScopeRef(s)           ::= "<s.scope>"
DynScopeAttrRef(s)       ::= "<s.scope>.peek().<s.attr>"
DynScopeAttrRef_negIndex(s, indexChunks) ::=
    "<s.scope>.get(<s.scope>.size()-<indexChunks>-1).<s.attr>"
DynScopeAttrRef_index(s, indexChunks)    ::=
    "<s.scope>.get(<indexChunks>).<s.attr>"
SetDynScopeAttr(s, rhsChunks)            ::=
    "<s.scope>.peek().<s.attr> =<rhsChunks>;"
SetDynScopeAttr_negIndex(s, indexChunks, rhsChunks) ::=
    "<s.scope>.get(<s.scope>.size()-<indexChunks>-1).<s.attr> =<rhsChunks>;"
SetDynScopeAttr_index(s, indexChunks, rhsChunks)    ::=
    "<s.scope>.get(<indexChunks>).<s.attr> =<rhsChunks>;"

AddToLabelList(a) ::= "_localctx.<a.listName>.add(<labelref(first(a.opWithResultToAdd.labels))>);"

TokenDecl(t) ::= "Token <t.name>;"
TokenTypeDecl(t) ::= "int <t.name>;"
TokenListDecl(t) ::= "List\<Token> <t.name> = new ArrayList\<Token>();"
RuleContextDecl(r) ::= "<r.ctxName> <r.name>;"
RuleContextListDecl(rdecl) ::= "List\<<rdecl.decl.ctxName>> <rdecl.name> = new ArrayList\<<rdecl.decl.ctxName>>();"

/** Default RuleContext type name for a Parser rule */
ParserRuleContext() ::= "ParserRuleContext"

RuleDynamicScopeStructName(ruleName) ::= "<ruleName>_stk"
ImplicitTokenLabel(tokenName) ::= "_t<tokenName>"
ImplicitRuleLabel(ruleName)   ::= "_r<ruleName>"

CaptureNextToken(d) ::= "<d.varName> = input.LT(1);"
CaptureNextTokenType(d) ::= "<d.varName> = input.LA(1);"

StructDecl(s,attrs) ::= <<
public static class <s.name> extends ParserRuleContext {
    <attrs:{a | public <a>;}; separator="\n">
    public <s.name>(ParserRuleContext parent, int state<s.ctorAttrs:{a | , <a>}>) {
    	super(parent, state);
        <s.ctorAttrs:{a | this.<a.name> = <a.name>;}; separator="\n">
    }
}
>>

AttributeDecl(d) ::= "<d.decl>"

/** If we don't know location of label def, use this template */
labelref(x) ::= "<if(!x.isLocal)>_localctx.<endif><x.name>"

// AST stuff (TODO: separate?)

KidsListDecl(d) ::= "List <d.name> = new ArrayList(5);"
RootDecl(d)     ::= "Object <d.name> = _adaptor.nil();"
RootName(level)     ::= "_root<level>"
KidsListName(level) ::= "_kids<level>"

AddTokenLeaf(a) ::= "_adaptor.addChild(_root0, _adaptor.create(<labelref(a.label)>));"
AddRuleLeaf(a) ::= "_adaptor.addChild(_root0, <labelref(a.label)>.tree);"
RuleBecomeRoot(r) ::= "_root0 = _adaptor.becomeRoot(<labelref(r.label)>.tree, _root0);"
TokenBecomeRoot(t) ::= "_root0 = _adaptor.becomeRoot(_adaptor.create(<labelref(t.label)>), _root0);"
AssignTreeResult(a) ::= <<
_root0 = _adaptor.rulePostProcessing(_root0);
_localctx.tree = _root0;
_adaptor.setTokenBoundaries(_localctx.tree, _localctx.start, _localctx.stop);
>>

/*
BitSetDecl(b) ::= <<
public static final LABitSet <b.name>=new LABitSet(new long[]{<b.hexWords:{it|<it>L};separator=",">}<if(b.fset.EOF)>, true<endif>);
>>
*/

LexerFile(lexerFile, lexer, namedActions) ::= <<
// $ANTLR ANTLRVersion> <lexerFile.fileName> generatedTimestamp>
<namedActions.header>
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.misc.*;

<lexer>
>>

Lexer(lexer, atn, actions, sempreds) ::= <<
public class <lexer.name> extends Lexer {
    public static final int
        <lexer.tokens:{k | <k>=<lexer.tokens.(k)>}; separator=", ", wrap, anchor>;
    <lexer.modes:{m| public static final int <m> = <i0>;}; separator="\n">

    public static final String[] tokenNames = {
        "\<INVALID>", "\<INVALID>", "\<INVALID>",
        <lexer.tokenNames:{k | "<k>"}; separator=", ", wrap, anchor>
    };
    public static final String[] ruleNames = {
        "\<INVALID>",
        <lexer.ruleNames:{r | "<r>"}; separator=", ", wrap, anchor>
    };

    <namedActions.members>

    public <lexer.name>(CharStream input) {
        super(input);
		_interp = new LexerInterpreter(this,_ATN);
    }

    public String getGrammarFileName() { return "<lexerFile.fileName>"; }
    @Override
    public String[] getTokenNames() { return tokenNames; }
    @Override
    public String[] getRuleNames() { return ruleNames; }
	@Override
	public ATN getATN() { return _ATN; }

    <lexer.namedActions.members>

    <dumpActions(actions,sempreds)>
    <atn>
}
>>


SerializedATN(model) ::= <<
public static final String _serializedATN =
	"<model.serialized; wrap={"+<\n>"}, anchor>";
public static final ATN _ATN =
    ATNInterpreter.deserialize(_serializedATN.toCharArray());
static {
    org.antlr.v4.tool.DOTGenerator dot = new org.antlr.v4.tool.DOTGenerator(null);
	//System.out.println(dot.getDOT(_ATN.decisionToATNState.get(0)));
}
>>

actionMethod(name, ruleIndex, actions) ::= <<
public void <name>_actions(int action) {
    System.out.println("exec action "+action);
    switch ( action ) {
    <actions:{a |
    case <i0> :
        <a>
        break;
    }>
    }
}<\n>
>>

sempredMethod(name, ruleIndex, preds) ::= <<
public boolean <name>_sempreds(int pred) {
    switch ( pred ) {
    <preds:{p |
    case <i0> :
        return <p>;
    }>
    default : return false;
    }
}<\n>
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<javaTypeInitMap.(typeName)>
>>

codeFileExtension() ::= ".java"

true() ::= "true"
false() ::= "false"
