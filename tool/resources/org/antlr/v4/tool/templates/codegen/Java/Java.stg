javaTypeInitMap ::= [
	"int":"0",
	"long":"0",
	"float":"0.0f",
	"double":"0.0",
	"boolean":"false",
	"byte":"0",
	"short":"0",
	"char":"0",
	default:"null" // anything other than an atomic type
]

// args must be <object-model-object>, <fields-resulting-in-STs>

ParserFile(file, parser, dfaDecls, bitSetDecls, namedActions) ::= <<
// $ANTLR ANTLRVersion> <file.fileName> generatedTimestamp>
<namedActions.header>
import org.antlr.v4.runtime.NoViableAltException;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.EarlyExitException;
import org.antlr.v4.runtime.RecognizerSharedState;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.runtime.*;

<parser>
>>

Parser(parser, scopes, funcs) ::= <<
public class <parser.name> extends Parser {
<!
	public enum TokenType {
		EOF(-1),
	    <parser.tokens.keys:{k | <k>(<parser.tokens.(k)>)}; separator=", ">
	    ;
    	public int type;
		TokenType(int type) { this.type = type; }
	}
!>	
    <parser.tokens.keys:{k | public static final int <k>=<parser.tokens.(k)>;}; separator="\n">
    <scopes>
    <namedActions.members>
    <parser:ctor()>
    <funcs; separator="\n">
    <dfaDecls; separator="\n">
    <bitSetDecls; separator="\n">
}
>>

ctor(p) ::= <<
public <p.name>(TokenStream input) {
    this(input, new RecognizerSharedState());
}
public <p.name>(TokenStream input, RecognizerSharedState state) {
    super(input, state);
}
>>

/*
   // S.g:5:1: b returns [String q, float x] : A ;
    public final S.b_return b() throws RecognitionException {
        b_stack.push(new b_scope());
        S.b_return retval = new S.b_return();
*/

RuleFunction(f,code,decls,context,scope,namedActions,finallyAction) ::= <<
<context>
<scope>

<if(f.modifiers)><f.modifiers:{f | <f> }><else>public final <endif><f.ctxType> <f.name>(<f.ctxType> _ctx) throws RecognitionException {
    state.ctx.push(_ctx);
<if(f.scope)>
    <f.scope.name>_stack.push(new <f.scope.name>());
<endif>
    <f.globalScopesUsed:{s | <s>_stack.push(new <s>());}; separator="\n">
    <namedActions.init>
    <decls; separator="\n">
	try {
	    <code>
	}
	catch (RecognitionException re) {
		reportError(re);
		recover();
	}
	finally {
        <namedActions.after>
        <f.globalScopesUsed:{s | <s>_stack.pop();}; separator="\n">
        <if(f.scope)><f.scope.name>_stack.pop();<endif>
        <finallyAction>
        <if(f.ctxType)>return (<f.ctxType>)state.ctx.pop();<endif>
	}
}
>>

/** Convenience method to call from outside */
StartRuleFunction(f) ::= <<
<if(f.modifiers)><f.modifiers:{f | <f> }><else>public final <endif><f.ctxType> <f.name>(<f.args; separator=", ">) throws RecognitionException {
    return <f.name>(new <f.ctxType>(<f.args:{a | <a.name>, }>LABitSet.EOF_SET));
}
>>

CodeBlock(c, ops) ::= <<
<ops; separator="\n">
>>

LL1AltBlock(choice, alts, error) ::= <<
switch ( state.input.LA(1) ) {
	<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
	default :
		<error>
}
>>

// follow set included as choice by analysis
LL1OptionalBlock ::= LL1AltBlock

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
<preamble; separator="\n">
if ( <expr> ) {
    <alts; separator="\n">
}
else if ( !(<followExpr>) ) <error>
>>

LL1StarBlock(choice, alts, sync) ::= <<
<choice.loopLabel>:
while (true) {
	switch ( state.input.LA(1) ) {
		<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
		<alt>
		break;}; separator="\n">
		<cases(ttypes=choice.exitLook)>
		    break <choice.loopLabel>;
	}
    <sync>
}
>>

LL1StarBlockSingleAlt(choice, expr, alts, preamble, iteration, sync) ::= <<
<preamble; separator="\n">
while ( <expr> ) {
    <alts; separator="\n">
    <iteration>
    <sync>
}
>>

LL1PlusBlock(choice, alts, earlyExitError, sync, iterationSync) ::= <<
<sync>
int <choice.loopCounterVar> = 0;
<choice.loopLabel>:
while (true) {
	switch ( state.input.LA(1) ) {
		<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
		<cases(ttypes=choice.exitLook)>
		    if ( <choice.loopCounterVar> >= 1 ) break <choice.loopLabel>;
		    else <earlyExitError>
	}
	<choice.loopCounterVar>++;
    <iterationSync>
}
>>

LL1PlusBlockSingleAlt(choice, expr, alts, preamble, iteration,
                      earlyExitError, sync, iterationSync) ::=
<<
<sync>
<preamble; separator="\n">
do {
    <alts; separator="\n">
    <iteration>
    <iterationSync>
} while ( <expr> );
>>

Sync(s) ::= "sync(<s.expecting.name>);"

ThrowNoViableAlt(t) ::= "throw new NoViableAltException(this, <t.expecting.name>);"
ThrowEarlyExitException(t) ::= "throw new EarlyExitException(this, <t.expecting.name>);"

TestSet(s) ::= <<
<s.set.name>.member(state.input.LA(1))
>>

TestSetInline(s) ::= <<
<s.ttypes:{ttype | <s.varName>==<ttype>}; separator=" || ">
>>

cases(ttypes) ::= <<
<ttypes:{t | case <t>:}; separator="\n">
>>

InvokeRule(r) ::= <<
<if(r.labels)><r.labels:{l | <l> = }><endif><r.name>(new <r.ctxName>(<r.argExprs:{e|<e>,}><r.follow.name>));
>>

MatchToken(m) ::= <<
<if(m.labels)><m.labels:{l | <l> = }>(Token)<endif>match(<m.name>, <m.follow.name>);
>>

// ACTION STUFF

Action(a, chunks) ::= "<chunks>"

SemPred(p) ::= <<
if (!(<p.ast.text>)) throw new FailedPredicateException(this,"<ruleName>", "<description>");
>>

ActionText(t) ::= "<t.text>"
ArgRef(a) ::= "_ctx.<a.name>"
RetValueRef(a) ::= "_ctx.<a.name>"
QRetValueRef(a) ::= "<a.dict>.<a.name>"
/** How to translate $tokenLabel */
TokenRef(t) ::= "<t.name>"
SetAttr(s,rhsChunks) ::= "_ctx.<s.name> = <rhsChunks>;"
SetQAttr(s,rhsChunks) ::= "<s.dict>.<s.name> = <rhsChunks>;"

TokenPropertyRef_text(t) ::= "(<t.label>!=null?<t.label>.getText():null)"
TokenPropertyRef_type(t) ::= "(<t.label>!=null?<t.label>.getType():0)"
TokenPropertyRef_line(t) ::= "(<t.label>!=null?<t.label>.getLine():0)"
TokenPropertyRef_pos(t) ::= "(<t.label>!=null?<t.label>.getCharPositionInLine():0)"
TokenPropertyRef_channel(t) ::= "(<t.label>!=null?<t.label>.getChannel():0)"
TokenPropertyRef_index(t) ::= "(<t.label>!=null?<t.label>.getTokenIndex():0)"
TokenPropertyRef_tree(t) ::= "<t.label>_tree"
TokenPropertyRef_int(t) ::= "(<t.label>!=null?Integer.valueOf(<t.label>.getText()):0)"

RulePropertyRef_start(r) ::= "(<r.label>!=null?((<file.TokenLabelType>)<r.label>.start):null)"
RulePropertyRef_stop(r)  ::= "(<r.label>!=null?((<file.TokenLabelType>)<r.label>.stop):null)"
RulePropertyRef_tree(r)  ::= "(<r.label>!=null?((<file.ASTLabelType>)<r.label>.tree):null)"
RulePropertyRef_text(r)  ::= "(<r.label>!=null?((TokenStream)state.input).toString(<r.label>.start,<r.label>.stop):null)"
RulePropertyRef_st(r)    ::= "(<r.label>!=null?<r.label>.st:null)"

DynScopeRef(s)           ::= "<s.scope>_stack"
DynScopeAttrRef(s)       ::= "<s.scope>_stack.peek().<s.attr>"
DynScopeAttrRef_negIndex(s, indexChunks) ::= 
    "<s.scope>_stack.get(<s.scope>_stack.size()-<indexChunks>-1).<s.attr>"
DynScopeAttrRef_index(s, indexChunks)    ::=
    "<s.scope>_stack.get(<indexChunks>).<s.attr>"
SetDynScopeAttr(s, rhsChunks)            ::=
    "<s.scope>_stack.peek().<s.attr> =<rhsChunks>;"
SetDynScopeAttr_negIndex(s, indexChunks, rhsChunks) ::=
    "<s.scope>_stack.get(<s.scope>_stack.size()-<indexChunks>-1).<s.attr> =<rhsChunks>;"
SetDynScopeAttr_index(s, indexChunks, rhsChunks)    ::=
    "<s.scope>_stack.get(<indexChunks>).<s.attr> =<rhsChunks>;"

AddToList(a) ::= "<a.listName>.add(<first(a.opWithResultToAdd.labels)>);"

TokenDecl(t) ::= "Token <t.name>;"
TokenTypeDecl(t) ::= "int <t.name>;"
TokenListDecl(t) ::= "List\<Token> <t.name> = new ArrayList\<Token>();"
RuleContextDecl(r) ::= "<r.ctxName> <r.name>;"

CaptureNextToken(d) ::= "<d.varName> = state.input.LT(1);"
CaptureNextTokenType(d) ::= "<d.varName> = state.input.LA(1);"

StructDecl(s,attrs) ::= <<
public static class <s.name> extends ParserRuleContext {
    <attrs:{a | <a>;}; separator="\n">
<if(s.ctorAttrs)>
    public <s.name>(<s.ctorAttrs:{a | <a>,}> LABitSet follow) {
        super(follow);
        <s.ctorAttrs:{a | this.<a.name> = <a.name>;}; separator="\n">
    }
<endif>
};
>>

DynamicScopeStruct(d,attrs) ::= <<
public static class <d.name> {
    <attrs:{a | <a>;}; separator="\n">
};
public QStack\<<d.name>\> <d.name>_stack = new QStack\<<d.name>\>();
>>

AttributeDecl(d) ::= "<d.decl>"

DFADecl(dfa) ::= <<
// define <dfa.name>
>>

BitSetDecl(b) ::= <<
public static final LABitSet <b.name>=new LABitSet(new long[]{<b.hexWords:{<it>L};separator=",">}<if(b.fset.EOF)>, true<endif>);
>>

LexerFile(fileName, lexer) ::= <<
// $ANTLR ANTLRVersion> <fileName> generatedTimestamp>
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.LexerSharedState;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.pda.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.runtime.*;

<lexer>
>>

Lexer(lexerName, modes, pdas, tokens, actions, sempreds, namedActions) ::= <<
public class <lexerName> extends Lexer {
    <tokens.keys:{k | public static final int <k>=<tokens.(k)>;}; separator="\n">
    <modes:{m| public static final int <m> = <i0>;}; separator="\n">

    public <lexerName>(CharStream input) {
        this(input, new LexerSharedState());
    }
    public <lexerName>(CharStream input, LexerSharedState state) {
        super(input,state);
	    modeToPDA = new PDA[] { <modes:{m | new <m>_PDA()}; separator=", "> };
    }
    public String getGrammarFileName() { return "<fileName>"; }

    <namedActions.members>

    <actions>
    <sempreds>
    <pdas>
}
>>

PDA(name, model, actions, sempreds) ::= <<
public static final byte[] <name>_code = {
    <model.code; separator=", ">
};
public static final int[] <name>_tokenTypeToAddr = {
    <model.altToAddr; separator=", ">
};
public static final int[][] <name>charToAddr = {
    <model.charToAddr:{addrs | /* <i0> */ {<addrs; separator=", ">\}}; null="null", separator=",\n">
};

public final class <name>_PDA extends PDA {
	<if(actions)>
    public void action(int r, int a) {
        switch ( r ) {
	    <actions:{a |
	    case <a.ruleIndex> : <a.name>_actions(a); break;
	    }>
	    }
	}
	<endif>
	<if(sempreds)>
    public void sempred(int r, int a) {
        switch ( r ) {
	    <sempreds:{p |
	    case <p.ruleIndex> : return <p.name>_sempreds(a);
	    }>
	    }
	}
	<endif>
    public <name>_PDA() {
    	super(<name>_code, <name>_tokenTypeToAddr, <model.nLabels>);
    	this.charToAddr = <name>charToAddr;
    }
}<\n>
>>

actionMethod(name, actions, ruleIndex) ::= <<
public void <name>_actions(int action) {
    switch ( action ) {
    <actions:{a |
    case <i0> :
        <a>
        break;
    }>
    }
}
>>

sempredMethod(name, preds) ::= <<
public boolean <name>_sempreds(int pred) {
    switch ( pred ) {
    <preds:{p |
    case <i0> :
        return <p>;
    }>
    default : return false;
    }
}
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<javaTypeInitMap.(typeName)>
>>

codeFileExtension() ::= ".java"

true() ::= "true"
false() ::= "false"