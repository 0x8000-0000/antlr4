javaTypeInitMap ::= [
	"int":"0",
	"long":"0",
	"float":"0.0f",
	"double":"0.0",
	"boolean":"false",
	"byte":"0",
	"short":"0",
	"char":"0",
	default:"null" // anything other than an atomic type
]

// args must be <object-model-object>, <fields-resulting-in-STs>

ParserFile(file, parser, dfaDecls, bitSetDecls) ::= <<
// $ANTLR ANTLRVersion> <file.fileName> generatedTimestamp>
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.RecognizerSharedState;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.runtime.*;

<parser>
>>

Parser(p, funcs) ::= <<
public class <p.name> extends Parser {
<!
	public enum TokenType {
		EOF(-1),
	    <p.tokens.keys:{k | <k>(<p.tokens.(k)>)}; separator=", ">
	    ;
    	public int type;
		TokenType(int type) { this.type = type; }
	}
!>	
    <p.tokens.keys:{k | public static final int <k>=<p.tokens.(k)>;}; separator="\n">
    <p:ctor()>
    <funcs; separator="\n">
    <dfaDecls; separator="\n">
    <bitSetDecls; separator="\n">
}
>>

ctor(p) ::= <<
public <p.name>(TokenStream input) {
    this(input, new RecognizerSharedState());
}
public <p.name>(TokenStream input, RecognizerSharedState state) {
    super(input, state);
}
>>

/*
   // S.g:5:1: b returns [String q, float x] : A ;
    public final S.b_return b() throws RecognitionException {
        b_stack.push(new b_scope());
        S.b_return retval = new S.b_return();
*/

RuleFunction(f,code,decls,context,scope) ::= <<
<context>
<scope>

<if(f.modifiers)><f.modifiers:{f | <f> }><else>public final <endif><if(f.ctxType)><f.ctxType><else>void<endif> <f.name>(<f.ctxType> _ctx) throws RecognitionException {
<if(f.scope)>
    <f.scope.name>_stack.push(new <f.scope.name>());
<endif>
<if(f.ctxType)>
    state.ctx.push(_ctx);
<endif>
    <decls; separator="\n">
	try {
	    <code>
	}
	finally {
        <if(f.scope)><f.scope.name>_stack.pop();<endif>
        <if(f.ctxType)>return (<f.ctxType>)state.ctx.pop();<endif>
	}
}
>>

CodeBlock(c, ops) ::= <<
<ops; separator="\n">
>>

LL1Choice(choice, alts) ::= <<
switch ( input.LA(1) ) {
	<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
	default :
	    error
}
>>

// follow set included as choice by analysis
LL1OptionalBlock ::= LL1Choice

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble) ::= <<
<preamble; separator="\n">
if ( <expr> ) {
    <alts; separator="\n">
}
else {
    NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
}
>>

LL1StarBlock(choice, alts) ::= <<
<choice.loopLabel>:
while (true) {
	switch ( input.LA(1) ) {
		<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
		<alt>
		break;}; separator="\n">
		<cases(ttypes=choice.exitLook)>
		    break <choice.loopLabel>;
		default :
		    error
	}
}
>>

LL1StarBlockSingleAlt(choice, expr, alts, preamble, iteration) ::= <<
<preamble; separator="\n">
while ( <expr> ) {
    <alts; separator="\n">
    <iteration>
}
>>

LL1PlusBlock(choice, alts) ::= <<
int <choice.loopCounterVar> = 0;
<choice.loopLabel>:
while (true) {
	switch ( input.LA(1) ) {
		<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
		<cases(ttypes=choice.exitLook)>
		    if ( <choice.loopCounterVar> >= 1 ) break <choice.loopLabel>;
		    else error
		default :
		    error
	}
}
>>

LL1PlusBlockSingleAlt(choice, expr, alts, preamble, iteration) ::= <<
<preamble; separator="\n">
do {
    <alts; separator="\n">
    <iteration>
} while ( <expr> );
>>

TestSet(s) ::= <<
<s.set.name>.member(input.LA(1))
>>

TestSetInline(s) ::= <<
<s.ttypes:{ttype | <s.varName>==<ttype>}; separator=" || ">
>>

cases(ttypes) ::= <<
<ttypes:{t | case <t>:}; separator="\n">
>>

InvokeRule(r) ::= <<
<if(r.label)><r.label> = <endif><r.name>(new <r.ctxName>(<r.argExprs:{e|<e>,}><r.follow.name>));
>>

MatchToken(m) ::= <<
<if(m.label)><m.label> = (Token)<endif>match(<m.name>, <m.follow.name>);
>>

// ACTION STUFF

Action(a, chunks) ::= "<chunks>"

SemPred(p) ::= <<
if (!(<p.ast.text>)) throw new FailedPredicateException(input, "<ruleName>", "<description>");
>>

ActionText(t) ::= "<t.text>"
ArgRef(a) ::= "_ctx.<a.name>"
RetValueRef(a) ::= "_ctx.<a.name>"
SetAttr(s,rhsChunks) ::= "_ctx.<s.name> = <rhsChunks>;"

AddToList(a) ::= "<a.listName>.add(<a.opWithResultToAdd.label>);"

TokenDecl(t) ::= "Token <t.name>;"
TokenListDecl(t) ::= "List\<Token> <t.name> = new ArrayList\<Token>();"
RuleContextDecl(r) ::= "<r.ctxName> <r.name>;"

CaptureNextToken(d) ::= "<d.varName> = input.LA(1);"

StructDecl(s,attrs) ::= <<
public static class <s.name> extends ParserRuleContext {
    <attrs:{a | <a>;}; separator="\n">
<if(s.ctorAttrs)>
    public <s.name>(<s.ctorAttrs; separator=", ">) {
        <s.ctorAttrs:{a | this.<a.name> = <a.name>;}; separator="\n">
    }
<endif>
};
>>

DynamicScopeStruct(d,attrs) ::= <<
public static class <d.name> {
    <attrs:{a | <a>;}; separator="\n">
};
public QStack\<<f.scope.name>\> <f.scope.name>_stack = new QStack\<<f.scope.name>\>();
>>

AttributeDecl(d) ::= "<d.decl>"

DFADecl(dfa) ::= <<
// define <dfa.name>
>>

BitSetDecl(b) ::= <<
public static final LABitSet <b.name>=new LABitSet(new long[]{<b.fset.bits:{<it>L};separator=",">}<if(b.fset.EOF)>, true<endif>);
>>

LexerFile(fileName, lexer) ::= <<
// $ANTLR ANTLRVersion> <fileName> generatedTimestamp>
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.LexerSharedState;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.pda.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.runtime.*;

<lexer>
>>

Lexer(lexerName, modes, pdas, tokens, actions, sempreds) ::= <<
public class <lexerName> extends Lexer {
    <tokens.keys:{k | public static final int <k>=<tokens.(k)>;}; separator="\n">
    <modes:{m| public static final int <m> = <i0>;}; separator="\n">

    public <lexerName>(CharStream input) {
        this(input, new LexerSharedState());
    }
    public <lexerName>(CharStream input, LexerSharedState state) {
        super(input,state);
    }
    public String getGrammarFileName() { return "<fileName>"; }

    <actions>
    <sempreds>
    <pdas>

    static {
	    modeToPDA = new PDA[] { <modes:{m | new <m>_PDA()}; separator=", "> };
    }
}
>>

PDA(name, model, actions, sempreds) ::= <<
public static final class <name>_PDA extends PDA {
	public static final byte[] code = {
	    <model.code; separator=", ">
	};
	public static final int[] tokenTypeToAddr = {
	    <model.tokenTypeToAddr; separator=", ">
	};
	<if(actions)>
    public void action(int r, int a) {
	    <actions:{a |
        switch ( r ) {
	    case <i0> : <a.name>_actions(a); break;
	    }>
	    }
	}
	<endif>
	<if(sempreds)>
    public void sempred(int r, int a) {
	    <sempreds:{p |
        switch ( r ) {
	    case <i0> : return <p.name>_sempreds(a);
	    }>
	    }
	}
	<endif>
    public <name>_PDA() {
    	super(code, tokenTypeToAddr, <model.nLabels>);
    }
}
>>

actionMethod(name, actions) ::= <<
public void <name>_actions(int action) {
    switch ( action ) {
    <actions:{a |
    case <i0> :
        <a>
        break;
    }>
    }
}
>>

sempredMethod(name, preds) ::= <<
public boolean <name>_sempreds(int pred) {
    switch ( pred ) {
    <preds:{p |
    case <i0> :
        return <p>;
    }>
    default : return false;
    }
}
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<javaTypeInitMap.(typeName)>
>>

codeFileExtension() ::= ".java"

true() ::= "true"
false() ::= "false"