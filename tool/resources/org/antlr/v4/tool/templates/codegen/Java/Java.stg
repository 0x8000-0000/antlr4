javaTypeInitMap ::= [
	"int":"0",
	"long":"0",
	"float":"0.0f",
	"double":"0.0",
	"boolean":"false",
	"byte":"0",
	"short":"0",
	"char":"0",
	default:"null" // anything other than an atomic type
]

// args must be <object-model-object>, <fields-resulting-in-STs>
ParserFile(f, parser, dfaDecls, bitSetDecls) ::= <<
// $ANTLR ANTLRVersion> <f.fileName> generatedTimestamp>
import org.antlr.runtime.*;

<parser>
>>

Parser(p, funcs) ::= <<
public class <p.name> {
    <funcs; separator="\n">
    <dfaDecls; separator="\n">
    <bitSetDecls; separator="\n">
}
>>

/*
   // S.g:5:1: b returns [String q, float x] : A ;
    public final S.b_return b() throws RecognitionException {
        b_stack.push(new b_scope());
        S.b_return retval = new S.b_return();
*/

RuleFunction(f,code,decls,args,retvals,scope) ::= <<
<args>
<retvals>
<scope>
<if(f.modifiers)><f.modifiers:{f | <f> }><else>public final <endif><if(f.retType)><f.retType><else>void<endif> <f.name>() {
	<if(f.scope)><f.scope.name>.push(new <f.scope.name>);<endif>
    <decls; separator="\n">
	try {
	    <code>
	}
	finally {
		<if(f.scope)><f.scope.name>.pop();<endif>
		<if(f.args)>_args.pop();<endif>
		_follow.pop();
	}
}
>>

CodeBlock(c, ops) ::= <<
<ops; separator="\n">
>>

LL1Choice(choice, alts) ::= <<
switch ( input.LA(1) ) {
	<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
	default :
	    error
}
>>

// follow set included as choice by analysis
LL1OptionalBlock ::= LL1Choice

LL1OptionalBlockSingleAlt(choice, expr, alts, preamble) ::= <<
<preamble; separator="\n">
if ( <expr> ) {
    <alts; separator="\n">
}
else {
    NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
}
>>

LL1StarBlock(choice, alts) ::= <<
<choice.loopLabel>:
while (true) {
	switch ( input.LA(1) ) {
		<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
		<alt>
		break;}; separator="\n">
		<cases(ttypes=choice.exitLook)>
		    break <choice.loopLabel>;
		default :
		    error
	}
}
>>

LL1StarBlockSingleAlt(choice, expr, alts, preamble, iteration) ::= <<
<preamble; separator="\n">
while ( <expr> ) {
    <alts; separator="\n">
    <iteration>
}
>>

LL1PlusBlock(choice, alts) ::= <<
int <choice.loopCounterVar> = 0;
<choice.loopLabel>:
while (true) {
	switch ( input.LA(1) ) {
		<choice.altLook,alts:{look,alt| <cases(ttypes=look)>
	<alt>
	break;}; separator="\n">
		<cases(ttypes=choice.exitLook)>
		    if ( <choice.loopCounterVar> >= 1 ) break <choice.loopLabel>;
		    else error
		default :
		    error
	}
}
>>

LL1PlusBlockSingleAlt(choice, expr, alts, preamble, iteration) ::= <<
<preamble; separator="\n">
do {
    <alts; separator="\n">
    <iteration>
} while ( <expr> );
>>

TestSet(s) ::= <<
<s.set.name>.member(input.LA(1))
>>

TestSetInline(s) ::= <<
<s.ttypes:{ttype | <s.varName>==<ttype>}; separator=" || ">
>>

cases(ttypes) ::= <<
<ttypes:{t | case <t>:}; separator="\n">
>>

InvokeRule(r) ::= <<
_follow.push(<r.follow.name>);
<if(r.args)>_args.push(new );<endif>
<if(r.label)><r.label> = <endif><r.name>();
>>

MatchToken(m) ::= <<
<if(m.label)><m.label> = <endif>match(<m.name>, <m.follow.name>);
>>

Action(a) ::= "<a.ast.text>"
SemPred(p) ::= <<
if (!(<p.ast.text>)) throw new FailedPredicateException(input, "<ruleName>", "<description>");
>>

AddToList(a) ::= "<a.listName>.add(<a.opWithResultToAdd.label>);"

//Decl(d) ::= "<d.type> <d.varName> = <d.type:initValue()>;"

TokenDecl(t) ::= "Token <t.varName>;"
TokenListDecl(t) ::= "List\<Token> <t.varName> = new ArrayList\<Token>();"

CaptureNextToken(d) ::= "<d.varName> = input.LA(1);"

ArgStruct(rv,attrs) ::= <<
public static class <rv.name> {
    <attrs:{a | <a>;}; separator="\n">
    public <rv.name>(<attrs; separator=", ">) {
        <rv.attrs:{a | this.<a.name> = <a.name>;}; separator="\n">
    }
};
>>

ReturnValueStruct(rv,attrs) ::= <<
public static class <rv.name> extends ParserRuleReturnScope {
    <attrs:{a | <a>;}; separator="\n">
};
>>

DynamicScopeStruct(rv,attrs) ::= <<
public static class <rv.name> {
    <attrs:{a | <a>;}; separator="\n">
};
QStack b_stack = new QStack();
>>

AttributeDecl(d) ::= "<d.decl>"

DFADecl(dfa) ::= <<
// define <dfa.name>
>>

BitSetDecl(b) ::= <<
// define <b.name>
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<javaTypeInitMap.(typeName)>
>>

codeFileExtension() ::= ".java"

true() ::= "true"
false() ::= "false"