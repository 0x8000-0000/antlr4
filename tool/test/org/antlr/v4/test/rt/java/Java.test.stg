TestFile(file) ::= <<
package org.antlr.v4.test.rt.java;

import org.junit.Test;
import static org.junit.Assert.*;

<if(file.importErrorQueue)>
import org.antlr.v4.test.tool.ErrorQueue;
<endif>
<if(file.importGrammar)>
import org.antlr.v4.tool.Grammar;
<endif>

public class Test<file.name> extends BaseTest {

	<file.tests:{test | <test>}; separator="\n", wrap, anchor>

}
>>

LexerTestMethod(test) ::= <<
@Test
public void test<test.name>() throws Exception {
<test.slaveGrammars:{ grammar | 
	String slave_<grammar.grammarName> = <grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	mkdir(tmpdir);
	writeFile(tmpdir, "<grammar.grammarName>.g4", slave_<grammar.grammarName>);
	};separator="\n", wrap, anchor>
	String grammar = <test.grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	<test.afterGrammar>
	String found = execLexer("<test.grammar.grammarName>.g4", grammar, "<test.grammar.grammarName><if(!test.lexerOnly)>Lexer<endif>", "<test.input>", <test.showDFA>);
	assertEquals(<test.outputLines:{ line | "<line>\\n"};separator=" + \n", wrap, anchor>, found);
	<if(test.expectedErrors)>
	assertEquals("<test.expectedErrors>", this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
}

>>

CompositeLexerTestMethod(test) ::= <<
<LexerTestMethod(test)>
>>


ParserTestMethod(test) ::= <<
@Test
public void test<test.name>() throws Exception {
<test.slaveGrammars:{ grammar | 
	String slave_<grammar.grammarName> = <grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	mkdir(tmpdir);
	writeFile(tmpdir, "<grammar.grammarName>.g4", slave_<grammar.grammarName>);
	};separator="\n", wrap, anchor>
	String grammar = <test.grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	<test.afterGrammar>
	String found = execParser("<test.grammar.grammarName>.g4", grammar, "<test.grammar.grammarName>Parser", "<test.grammar.grammarName>Lexer", "<test.startRule>", "<test.input>", false);
	assertEquals("<test.expectedOutput>", found);
	<if(test.expectedErrors)>
	assertEquals("<test.expectedErrors>", this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
}

>>

CompositeParserTestMethod(test) ::= <<
<ParserTestMethod(test)>
>>

AbstractParserTestMethod(test) ::= <<
String test<test.name>(String input) throws Exception {
	String grammar = <test.grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	return execParser("<test.grammar.grammarName>.g4", grammar, "<test.grammar.grammarName>Parser", "<test.grammar.grammarName>Lexer", "<test.startRule>", input, false);
}

>>

ConcreteParserTestMethod(test) ::= <<
@Test
public void test<test.name>() throws Exception {
	String found = test<test.baseName>("<test.input>");
	assertEquals("<test.expectedOutput>", found);
	<if(test.expectedErrors)>
	assertEquals("<test.expectedErrors>", this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
}

>>

writeln(s) ::= <<System.out.println(<s>);>>

write(s) ::= <<document.getElementById('output').value += <s>;>>

assert(s) ::= <<console.assert(<s>);>>

LocalVar() ::= "var "

InitMember(n,v) ::= <%this.<n> = <v>;%>

GetMember(n) ::= <%this.<n>%>

SetMember(n,v) ::= <%this.<n> = <v>;%>

AddMember(n,v) ::= <%this.<n> += <v>;%>

PlusMember(v,n) ::= <%<v> + this.<n>%>

MemberEquals(n,v) ::= <%this.<n> === <v>%>

ModMemberEquals(n,m,v) ::= <%this.<n> % m === <v>%>

ModMemberNotEquals(n,m,v) ::= <%this.<n> % m != <v>%>

DumpDFA() ::= "this.dumpDFA();"

Pass() ::= ""

BuildParseTrees() ::= "this.buildParseTrees = true;"

BailErrorStrategy() ::= <%this._errHandler = new antlr4.error.BailErrorStrategy();%>

ToStringTree(s) ::= <%<s>.toStringTree(null, this);%>

Column() ::= "this.getCharPositionInLine()"

Text() ::= "this.getText()"

ValEquals(a,b) ::= <%<a>===<b>%>

TextEquals(a) ::= <%this.getText().equals("<a>")%>

PlusText(a) ::= <%"<a>" + this.getText()%>

InputText() ::= "this._input.getText()"

LTEquals(i, v) ::= <%this._input.LT(<i>).text===<v>%>

LANotEquals(i, v) ::= <%this._input.LA(<i>)!=<v>%>

TokenStartColumnEquals(i) ::= <%this._tokenStartCharPositionInLine==<i>%>

ImportListener(X) ::= <<var <X>Listener = require('./<X>Listener').<X>Listener;>>

GetExpectedTokenNames() ::= "this.getExpectedTokens().toString(this.tokenNames));"

WriteRuleInvocationStack() ::= "document.getElementById('output').value += antlr4.Utils.arrayToString(this.getRuleInvocationStack()) + '\\n';"

LL_EXACT_AMBIG_DETECTION() ::= <<this._interp.predictionMode = antlr4.atn.PredictionMode.LL_EXACT_AMBIG_DETECTION;>>

PositionAdjustingLexer() ::= <<

@Override
public Token nextToken() {
	if (!(_interp instanceof PositionAdjustingLexerATNSimulator)) {
		_interp = new PositionAdjustingLexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);
	}

	return super.nextToken();
}

@Override
public Token emit() {
	switch (_type) {
	case TOKENS:
		handleAcceptPositionForKeyword("tokens");
		break;

	case LABEL:
		handleAcceptPositionForIdentifier();
		break;

	default:
		break;
	}

	return super.emit();
}

private boolean handleAcceptPositionForIdentifier() {
	String tokenText = getText();
	int identifierLength = 0;
	while (identifierLength \< tokenText.length() && isIdentifierChar(tokenText.charAt(identifierLength))) {
		identifierLength++;
	}

	if (getInputStream().index() > _tokenStartCharIndex + identifierLength) {
		int offset = identifierLength - 1;
		getInterpreter().resetAcceptPosition(getInputStream(), _tokenStartCharIndex + offset, _tokenStartLine, _tokenStartCharPositionInLine + offset);
		return true;
	}

	return false;
}

private boolean handleAcceptPositionForKeyword(String keyword) {
	if (getInputStream().index() > _tokenStartCharIndex + keyword.length()) {
		int offset = keyword.length() - 1;
		getInterpreter().resetAcceptPosition(getInputStream(), _tokenStartCharIndex + offset, _tokenStartLine, _tokenStartCharPositionInLine + offset);
		return true;
	}

	return false;
}

@Override
public PositionAdjustingLexerATNSimulator getInterpreter() {
	return (PositionAdjustingLexerATNSimulator)super.getInterpreter();
}

private static boolean isIdentifierChar(char c) {
	return Character.isLetterOrDigit(c) || c == '_';
}

protected static class PositionAdjustingLexerATNSimulator extends LexerATNSimulator {

	public PositionAdjustingLexerATNSimulator(Lexer recog, ATN atn,
											  DFA[] decisionToDFA,
											  PredictionContextCache sharedContextCache)
	{
		super(recog, atn, decisionToDFA, sharedContextCache);
	}

	protected void resetAcceptPosition(CharStream input, int index, int line, int charPositionInLine) {
		input.seek(index);
		this.line = line;
		this.charPositionInLine = charPositionInLine;
		consume(input);
	}

}

>>

BasicListener(X) ::= <<
this.LeafListener = function() {
    this.visitTerminal = function(node) {
    	document.getElementById('output').value += node.symbol.text + '\\n';
    };
    return this;
};
this.LeafListener.prototype = Object.create(<X>Listener.prototype);
this.LeafListener.prototype.constructor = this.LeafListener;

>>

walkListener(s) ::= <<
var walker = new antlr4.tree.ParseTreeWalker();
walker.walk(new this.LeafListener(), <s>);

>>

TokenGetterListener(X) ::= <<
this.LeafListener = function() {
    this.exitA = function(ctx) {
    	var str;
        if(ctx.getChildCount()===2) {
            str = ctx.INT(0).symbol.text + ' ' + ctx.INT(1).symbol.text + ' ' + antlr4.Utils.arrayToString(ctx.INT());
        } else {
            str = ctx.ID().symbol.toString();
        }
    	document.getElementById('output').value += str + '\\n';
    };
    return this;
};
this.LeafListener.prototype = Object.create(<X>Listener.prototype);\n" +
this.LeafListener.prototype.constructor = this.LeafListener;\n" +

>>

RuleGetterListener(X) ::= <<
this.LeafListener = function() {
    this.exitA = function(ctx) {
    	var str;
        if(ctx.getChildCount()===2) {
            str = ctx.b(0).start.text + ' ' + ctx.b(1).start.text + ' ' + ctx.b()[0].start.text;
        } else {
            str = ctx.b(0).start.text;
        }
    	document.getElementById('output').value += str + '\\n';
    };
    return this;
};
this.LeafListener.prototype = Object.create(<X>Listener.prototype);\n" +
this.LeafListener.prototype.constructor = this.LeafListener;\n" +

>>


LRListener(X) ::= <<
this.LeafListener = function() {
    this.exitE = function(ctx) {
    	var str;
        if(ctx.getChildCount()===3) {
            str = ctx.e(0).start.text + ' ' + ctx.e(1).start.text + ' ' + ctx.e()[0].start.text;
        } else {
            str = ctx.INT().symbol.text;
        }
    	document.getElementById('output').value += str + '\\n';
    };
    return this;
};
this.LeafListener.prototype = Object.create(<X>Listener.prototype);
this.LeafListener.prototype.constructor = this.LeafListener;

>>

LRWithLabelsListener(X) ::= <<
this.LeafListener = function() {
    this.exitCall = function(ctx) {
    	var str = ctx.e().start.text + ' ' + ctx.eList();
    	document.getElementById('output').value += str + '\\n';
    };
    this.exitInt = function(ctx) {
        var str = ctx.INT().symbol.text;
        document.getElementById('output').value += str + '\\n';
    };
    return this;
};
this.LeafListener.prototype = Object.create(<X>Listener.prototype);
this.LeafListener.prototype.constructor = this.LeafListener;

>>

DeclareContextListGettersFunction() ::= <<
	function foo() {
		var s = new SContext();
	    var a = s.a();
	    var b = s.b();
    };
>>

Declare_foo() ::= "this.foo = function() {document.getElementById('output').value += 'foo\\n'};"
			
Invoke_foo() ::= "this.foo();"

Declare_pred() ::= <<this.pred = function(v) {
	document.getElementById('output').value += 'eval=" + v.toString() + '\\n';
	return v;
};
>>

Invoke_pred(v) ::= <<this.pred(<v>)>>



